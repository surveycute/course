Content-Type: multipart/related; start=<op.mhtml.1299619803996.0f7b860c2b5de83b@192.168.1.3>; boundary=----------5jSlU8e2Sl6wqy2xOdNPzF
Content-Location: http://quirks.chat.ru/cpp/faq/
Subject: =?utf-8?Q?=D0=9A=D1=80=D0=B0=D1=82=D0=BA=D0=B8=D0=B9=20FAQ=20=D0=BF=D0=BE=20C++?=
MIME-Version: 1.0

------------5jSlU8e2Sl6wqy2xOdNPzF
Content-Disposition: inline; filename=default.htm
Content-Type: text/html; charset=koi8-r; name=default.htm
Content-ID: <op.mhtml.1299619803996.0f7b860c2b5de83b@192.168.1.3>
Content-Location: http://quirks.chat.ru/cpp/faq/
Content-Transfer-Encoding: 8bit

<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=koi8-r">
<meta name="Template"
content="C:\PROGRAM FILES\MICROSOFT OFFICE\OFFICE\html.dot">
<meta name="GENERATOR" content="Microsoft FrontPage Express 2.0">
<title>Краткий FAQ по C++</title>
</head>

<body><br>
<center>
<script language="JavaScript"> var loc = ''; </script>
<script language="JavaScript1.4">try{ var loc = escape(top.location.href); }catch(e){;}</script>
<script language="JavaScript">
var userid = 160233028; var page = 1;
var rndnum = Math.round(Math.random() * 999111);
document.write('<iframe src="http://ad16.bannerbank.ru/bb.cgi?cmd=ad&hreftarget=_blank&pubid=' + userid + '&pg=' + page + '&vbn=1966&w=600&h=90&num=1&r=ssi&ssi=nofillers&r=ssi&nocache=' + rndnum + '&ref=' + escape(document.referrer) + '&loc=' + loc + '" frameborder=0 vspace=0 hspace=0 width=600 height=90 marginwidth=0 marginheight=0 scrolling=no>');
document.write('<a href="http://ad16.bannerbank.ru/bb.cgi?cmd=go&pubid=' + userid + '&pg=' + page + '&vbn=1966&num=1&w=600&h=90&nocache=' + rndnum + '&loc=' + loc + '&ref=' + escape(document.referrer) + '" target="_blank">');
document.write('<img src="http://ad16.bannerbank.ru/bb.cgi?cmd=ad&pubid=' + userid + '&pg=' + page + '&vbn=1966&num=1&w=600&h=90&nocache=' + rndnum + '&ref=' + escape(document.referrer) + '&loc=' + loc + '" width=600 height=90 Alt="chat.ru" border=0></a></iframe>');
</script>
<!-- MobAdventure code start -->
<script language="JavaScript" src="http://static.mobadventure.com/images/ma/c.js"></script>
<script language="JavaScript">if (maCheckCookie()){document.write("<sc"+"ript language='JavaScript' src='http://ad.mobadventure.com/bb.cgi?cmd=ad&hreftarget=_blank&pubid=165710691&pg=1&r=js&ssi=nofillers&vbn=1976&num=1&w=0&h=0&&ref="+escape(document.referrer)+"&nocache="+Math.round(Math.random()*999111)+"'></sc"+"ript>");}</script>
<!-- MobAdventure code end -->
</center>
<br>


<p><font face="Times New Roman">Краткий FAQ по C++</font></p>

<p align="right"><a href="http://www.parashift.com/c++-faq-lite"><font
face="Times New Roman">To the complete English version of this
C++ FAQ Lite</font></a></p>

<p align="left"><a href="#contents"><font face="Times New Roman">К
оглавлению</font></a></p>

<p><font face="Times New Roman">[Этот документ
является переводом сборника
ответов на часто задаваемые
вопросы группы новостей </font><a
href="news:comp.lang.c++"><font color="#0000FF"><u>comp.lang.c++</u></font></a><font
face="Times New Roman">. Разделы будут
добавляться по мере их перевода.
Последнюю версию перевода можно
найти по адресу </font><a
href="http://quirks.chat.ru/cpp/faq"><font color="#0000FF"><u>http://quirks.chat.ru/cpp/faq</u></font></a><font
face="Times New Roman">. Ваши замечания и
дополнения вы можете высылать мне
по адресу: </font><a href="mailto:slava_mironov@mail.ru"><font
color="#0000FF"><u>slava_mironov@mail.ru</u></font></a><font
face="Times New Roman">. Последнюю английскую
версию этого сборника можно найти
на </font><a href="http://www.parashift.com/c++-faq-lite"><font
color="#0000FF"><u>http://www.parashift.com/c++-faq-lite</u></font></a>.]</p>

<p><font face="Times New Roman">[Авторские права:
Вы можете свободно использовать
этот документ в некоммерческих
целях и делать копии его или его
частей для личного использования,
при условии сохранения всей
информации об авторских правах,
включая это предупреждение. Не
допускается цитирование этого
документа без ссылки на источник.
Для коммерческого использования
этого документа требуется получить
разрешение, во-первых, автора
английской версии, во-вторых,
автора этого перевода. Автором
английской версии является Marshall Cline
(</font><a href="mailto:cline@parashift.com"><font
face="Times New Roman">cline@parashift.com</font></a><font
face="Times New Roman">), автором перевода -
Ярослав Миронов (</font><a
href="mailto:slava_mironov@mail.ru"><font face="Times New Roman">slava_mironov@mail.ru</font></a><font
face="Times New Roman">, </font><a
href="mailto:tada@mail.plus.net"><font face="Times New Roman">tada@mail.wplus.net</font></a><font
face="Times New Roman">).]</font></p>

<p><font face="Times New Roman">[Все
зарегистрированные торговые марки,
упоминающиеся в настоящем
документе, являются собственностью
своих владельцев.]</font></p>

<p><font face="Times New Roman">[В случае, если
какой-либо термин допускает
неоднозначный перевод на русский
язык, я старался передать его в
таком виде, как это сделано в
русской версии третьего издания
книги Бьерна Страуструпа <i>&quot;Язык
программирования С++&quot; (BINOM
Publishers/Невский Диалект, 1999)</i>, чтобы
избежать возможной путаницы. Часто
в таких случаях перевод термина
сопровождается его английским
оригиналом в скобках. - YM]</font></p>

<p>&nbsp;</p>

<p><a name="contents"><font size="4" face="Arial"><b><i>Оглавление</i></b></font></a></p>

<dir>
    <li><a name="contents"><font face="Times New Roman">РАЗДЕЛ
        [8]: Ссылки </font></a><p><a href="#s8p1"><font
        color="#0000FF" face="Times New Roman"><u>[8.1] Что
        такое ссылка?</u></font></a></p>
        <p><a href="#s8p2"><font color="#0000FF"
        face="Times New Roman"><u>[8.2] Что
        происходит в результате
        присваивания ссылке?</u></font></a></p>
        <p><a href="#s8p3"><font color="#0000FF"
        face="Times New Roman"><u>[8.3] Что
        происходит, когда я возвращаю
        из функции ссылку?</u></font></a></p>
        <p><a href="#s8p4"><font color="#0000FF"
        face="Times New Roman"><u>[8.4] Как можно
        переустановить ссылку, чтобы
        она ссылалась на другой объект?</u></font></a></p>
        <p><a href="#s8p5"><font color="#0000FF"
        face="Times New Roman"><u>[8.5] В каких
        случаях мне стоит использовать
        ссылки, и в каких - указатели? </u></font></a></p>
        <p><font face="Times New Roman">РАЗДЕЛ [9]:
        Встроенные (inline) функции </font></p>
        <p><a href="#s9p1"><font color="#0000FF"
        face="Times New Roman"><u>[9.1] Что такое
        встроенная функция?</u></font></a></p>
        <p><a href="#s9p2"><font color="#0000FF"
        face="Times New Roman"><u>[9.2] Как
        встроенные функции могут
        влиять на соотношение
        безопасности и скорости?</u></font></a></p>
        <p><a href="#s9p3"><font color="#0000FF"
        face="Times New Roman"><u>[9.3] Зачем мне
        использовать встроенные
        функции? Почему не
        использовать просто #define
        макросы?</u></font></a></p>
        <p><a href="#s9p4"><font color="#0000FF"
        face="Times New Roman"><u>[9.4] Что сделать,
        чтобы определить функцию - не
        член класса как встроенную?</u></font></a></p>
        <p><a href="#s9p5"><font color="#0000FF"
        face="Times New Roman"><u>[9.5] Как сделать
        встроенной функцию - член
        класса?</u></font></a></p>
        <p><a href="#s9p6"><font color="#0000FF"
        face="Times New Roman"><u>[9.6] Есть ли
        другой способ определить
        встроенную функцию - член
        класса?</u></font></a></p>
        <p><a href="#s9p7"><font color="#0000FF"
        face="Times New Roman"><u>[9.7] Обязательно
        ли встроенные функции приведут
        к увеличению
        производительности?</u></font></a><font
        face="Times New Roman"> </font></p>
        <p><font face="Times New Roman">РАЗДЕЛ [10]:
        Конструкторы </font></p>
        <p><a href="#s10p1"><font color="#0000FF"
        face="Times New Roman"><u>[10.1] Что такое
        конструкторы?</u></font></a></p>
        <p><a href="#s10p2"><font color="#0000FF"
        face="Times New Roman"><u>[10.2] Есть ли
        разница между объявлениями List
        x; и List x();?</u></font></a></p>
        <p><a href="#s10p3"><font color="#0000FF"
        face="Times New Roman"><u>[10.3] Как из одного
        конструктора вызвать другой
        конструктор для инициализации
        этого объекта?</u></font></a></p>
        <p><a href="#s10p4"><font color="#0000FF"
        face="Times New Roman"><u>[10.4] Всегда ли
        конструктор по умолчанию для
        Fred выглядит как Fred::Fred()?</u></font></a></p>
        <p><a href="#s10p5"><font color="#0000FF"
        face="Times New Roman"><u>[10.5] Какой
        конструктор будет вызван, если
        я создаю массив объектов типа
        Fred?</u></font></a></p>
        <p><a href="#s10p6"><font color="#0000FF"
        face="Times New Roman"><u>[10.6] Должны ли мои
        конструкторы использовать
        &quot;списки инициализации&quot;
        или &quot;присваивания
        значений&quot;?</u></font></a></p>
        <p><a href="#s10p7"><font color="#0000FF"
        face="Times New Roman"><u>[10.7] Можно ли
        пользоваться указателем this в
        конструкторе?</u></font></a></p>
        <p><a href="#s10p8"><font color="#0000FF"
        face="Times New Roman"><u>[10.8] Что такое
        &quot;именованный конструктор&quot;
        (&quot;Named Constructor Idiom&quot;)?</u></font></a></p>
        <p><a href="#s10p9"><font color="#0000FF"
        face="Times New Roman"><u>[10.9] Почему я не
        могу проинициализировать
        статический член класса в
        списке инициализации
        конструктора?</u></font></a></p>
        <p><a href="#s10p10"><font color="#0000FF"
        face="Times New Roman"><u>[10.10] Почему
        классы со статическими данными
        получают ошибки при
        компоновке?</u></font></a></p>
        <p><a href="#s10p11"><font color="#0000FF"
        face="Times New Roman"><u>[10.11] Что такое
        ошибка в порядке статической
        инициализации (&quot;static initialization
        order fiasco&quot;)?</u></font></a></p>
        <p><a href="#s10p12"><font color="#0000FF"
        face="Times New Roman"><u>[10.12] Как
        предотвратить ошибку в порядке
        статической инициализации?</u></font></a></p>
        <p><a href="#s10p13"><font color="#0000FF"
        face="Times New Roman"><u>[10.13] Как бороться
        с ошибками порядка статической
        инициализации объектов -
        членов класса?</u></font></a></p>
        <p><a href="#s10p14"><font color="#0000FF"
        face="Times New Roman"><u>[10.14] Как мне
        обработать ошибку, которая
        произошла в конструкторе?</u></font></a></p>
        <p><font face="Times New Roman">Р</font>АЗДЕЛ<font
        face="Times New Roman"> [11]: Деструкторы</font></p>
        <p><a href="#s11p1"><font color="#0000FF"
        face="Times New Roman"><u>[11.1] Что такое
        деструктор?</u></font></a></p>
        <p><a href="#s11p2"><font color="#0000FF"
        face="Times New Roman"><u>[11.2] В каком
        порядке вызываются
        деструкторы для локальных
        объектов?</u></font></a></p>
        <p><a href="#s11p3"><font color="#0000FF"
        face="Times New Roman"><u>[11.3] В каком
        порядке вызываются
        деструкторы для массивов
        объектов</u></font></a>?</p>
        <p><a href="#s11p4"><font color="#0000FF"
        face="Times New Roman"><u>[11.4] Могу ли я
        перегрузить деструктор для
        своего класса?</u></font></a></p>
        <p><a href="#s11p5"><font color="#0000FF"><u>[11.</u></font><font
        color="#0000FF" face="Times New Roman"><u>5] Могу
        ли я явно вызвать деструктор
        для локальной переменной?</u></font></a></p>
        <p><a href="#s11p6"><font color="#0000FF"
        face="Times New Roman"><u>[11.6] А что если я
        хочу, чтобы локальная
        переменная &quot;умерла&quot;
        раньше закрывающей фигурной
        скобки? Могу ли я при крайней
        необходимости вызвать
        деструктор для локальной
        переменной?</u></font></a></p>
        <p><a href="#s11p7"><font color="#0000FF"
        face="Times New Roman"><u>[11.7] Хорошо, я не
        буду явно вызывать деструктор.
        Но как мне справиться с этой
        проблемой?</u></font></a></p>
        <p><a href="#s11p8"><font color="#0000FF"
        face="Times New Roman"><u>[11.8] А что делать,
        если я не могу поместить
        переменную в отдельный блок?</u></font></a></p>
        <p><a href="#s11p9"><font color="#0000FF"
        face="Times New Roman"><u>[11.9] А могу ли я
        явно вызывать деструктор для
        объекта, созданного при помощи
        new?</u></font></a></p>
        <p><a href="#s11p10"><font color="#0000FF"
        face="Times New Roman"><u>[11.10] Что такое
        &quot;синтаксис размещения&quot; new
        (&quot;placement new&quot;) и зачем он
        нужен?</u></font></a></p>
        <p><a href="#s11p11"><font color="#0000FF"
        face="Times New Roman"><u>[11.11] Когда я пишу
        деструктор, должен ли я явно
        вызывать деструкторы для
        объектов-членов моего класса?</u></font></a></p>
        <p><a href="#s11p12"><font color="#0000FF"
        face="Times New Roman"><u>[11.12] Когда я пишу
        деструктор производного
        класса, нужно ли мне явно
        вызывать деструктор предка?</u></font></a></p>
    </li>
</dir>

<p>&nbsp;</p>

<p><font size="4" face="Arial"><b><i>РАЗДЕЛ [8]:
Ссылки</i></b></font></p>

<p><a name="s8p1"></a><font face="Arial"><b>[8.1] Что
такое ссылка?</b></font></p>

<p><font face="Times New Roman">Ссылка </font>-<font
face="Times New Roman"> это псевдоним (другое
имя) для объекта.</font></p>

<p><font face="Times New Roman">Ссылки часто
используются для передачи
параметра по ссылке:</font></p>

<pre><font size="2">    void swap(int&amp; i, int&amp; j)
    {
        int tmp = i;
        i = j;
        j = tmp;
    }

    int main()
    {
        int x, y;
        // ...
        swap(x,y);
    }</font></pre>

<p><font face="Times New Roman">В этом примере <b><i>i</i></b>
и <b><i>j</i></b> </font>-<font face="Times New Roman">
псевдонимы для переменных <b><i>x</i></b>
и <b><i>y</i></b> функции <b><i>main</i></b>.
Другими словами, <b><i>i</i></b> - это <b><i>x</i></b>.
Не указатель на <b><i>x</i></b> и не копия <b><i>x</i></b>,
а сам <b><i>x</i></b>. Все, что вы делаете с <b><i>i</i></b>,
проделывается с <b><i>x</i></b>, и
наоборот.</font></p>

<p><font face="Times New Roman">Вот таким образом
вы как программист должны
воспринимать ссылки. Теперь, рискуя
дать вам неверное представление,
несколько слов о том, каков
механизм работы ссылок. В основе
ссылки <b><i>i</i></b> на объект <b><i>x</i></b> -
лежит, как правило, просто машинный
адрес объекта <b><i>x</i></b>. Но когда вы
пишете <b><i>i++</i></b>, компилятор
генерирует код, который
инкрементирует <b><i>x</i></b>. В
частности, сам адрес, который
компилятор использует, чтобы найти <b><i>x</i></b>,
остается неизменным. Программист
на С может думать об этом, как если
бы использовалась передача
параметра по указателю, в духе
языка С, но, во-первых, <b><i>&amp;</i></b>
(взятие адреса) было бы перемещено
из вызывающей функции в вызываемую,
и, во-вторых, в вызываемой функции
были бы убраны <b><i>*</i></b>
(разыменование). Другими словами,
программист на С может думать об <b><i>i</i></b>
как о макроопределении для <b><i>(*p)</i></b>,
где <b><i>p</i></b> - это указатель на <b><i>x</i></b>
(т.е., компилятор автоматически
разыменовывает подлежащий
указатель: <b><i>i++</i></b> заменяется на <b><i>(*p)++</i></b>,
а <b><i>i = 7</i></b> на <b><i>*p = 7</i></b>).</font></p>

<p><font face="Times New Roman">Важное замечание:
несмотря на то что в качестве
ссылки в окончательном машинном
коде часто используется адрес, не
думайте о ссылке просто как о
забавно выглядящем указателе на
объект. Ссылка - это объект. Это не
указатель на объект и не копия
объекта. Это сам объект.</font></p>

<p>&nbsp;</p>

<p><a name="s8p2"></a><font face="Arial"><b>[8.2] Что
происходит в результате
присваивания ссылке?</b></font></p>

<p><font face="Times New Roman">Вы меняете
состояние ссыльного объекта (того,
на который ссылается ссылка).</font></p>

<p><font face="Times New Roman">Помните: ссылка -
это сам объект, поэтому, изменяя
ссылку, вы меняете состояние
объекта, на который она ссылается.
На языке производителей
компиляторов ссылка - это lvalue (left value
- значение, которое может появиться
слева от оператора присваивания).</font></p>

<p>&nbsp;</p>

<p><a name="s8p3"></a><font face="Arial"><b>[8.3] Что
происходит, когда я возвращаю из
функции ссылку?</b></font></p>

<p><font face="Times New Roman">В этом случае
вызов функции может оказаться с
левой стороны оператора (операции)
присваивания.</font></p>

<p><font face="Times New Roman">На первый взгляд,
такая запись может показаться
странной. Например, запись <b><i>f() = 7</i></b>
выглядит бессмысленной. Однако,
если <b><i>a</i></b> - это объект класса <b><i>Array</i></b>,
для большинства людей запись <b><i>a[i]
= 7</i></b> является осмысленной, хотя <b><i>a[i]</i></b>
- это всего лишь замаскированный
вызов функции <b><i>Array::operator[](int)</i></b>,
которая является оператором
обращения по индексу для класса <b><i>Array</i></b>:</font></p>

<pre><font size="2">    class Array {
    public:
        int size() const;
        float&amp; operator[] (int index);
        // ...
    };

    int main()
    {
        Array a;
        for (int i = 0; i &lt; a.size(); ++i)
            a[i] = 7; // В этой строке вызывается Array::operator[](int)
    }</font></pre>

<p>&nbsp;</p>

<p><a name="s8p4"></a><font face="Arial"><b>[8.4] Как
можно переустановить ссылку, чтобы
она ссылалась на другой объект?</b></font></p>

<p><font face="Times New Roman">Невозможно в
принципе.</font></p>

<p><font face="Times New Roman">Невозможно
отделить ссылку от ее объекта.</font></p>

<p><font face="Times New Roman">В отличие от
указателя, ссылка, как только она
привязана к объекту, не может быть
&quot;перенаправлена&quot; на другой
объект. Ссылка сама по себе ничего
не представляет, у нее нет имени,
она сама - это другое имя для
объекта. Взятие адреса ссылки дает
адрес объекта, на который она
ссылается. Помните: ссылка - это
объект, на который она ссылается.</font></p>

<p><font face="Times New Roman">С этой точки
зрения, ссылка похожа на <b><i>const</i></b>
указатель [</font><a href="#s18p5"><font color="#0000FF"
face="Times New Roman"><u>18.5</u></font></a><font
face="Times New Roman">], такой как <b><i>int* const p</i></b>
(в отличие от указателя на <b><i>const</i></b>
[</font><a href="#s18p4"><font color="#0000FF"
face="Times New Roman"><u>18.4</u></font></a><font
face="Times New Roman">], такого как <b><i>const int* p</i></b>).
Несмотря на больш<b>у</b>ю схожесть,
не путайте ссылки с указателями -
это не одно и то же.</font></p>

<p>&nbsp;</p>

<p><a name="s8p5"></a><font face="Arial"><b>[8.5] В каких
случаях мне стоит использовать
ссылки, и в каких - указатели?</b></font></p>

<p><font face="Times New Roman">Используйте
ссылки, когда можете, а указатели -
когда это необходимо.</font></p>

<p><font face="Times New Roman">Ссылки обычно
предпочтительней указателей, когда
вам ненужно их &quot;перенаправлять&quot;
[</font><a href="#s8p4"><font color="#0000FF"
face="Times New Roman"><u>8.4</u></font></a><font
face="Times New Roman">]. Это обычно означает,
что ссылки особенно полезны в
открытой (public) части класса. Ссылки
обычно появляются на поверхности
объекта, а указатели спрятаны
внутри.</font></p>

<p><font face="Times New Roman">Исключением
является тот случай, когда параметр
или возвращаемый из функции объект
требует выделения &quot;охранного&quot;
значения для особых случаев. Это
обычно реализуется путем
взятия/возвращения указателя, и
обозначением особого случая при
помощи передачи нулевого указателя
(NULL). Ссылка же не может ссылаться на
разыменованный нулевой указатель.</font></p>

<p><font face="Times New Roman">Примечание:
программисты с опытом работы на С
часто недолюбливают ссылки, из-за
того что передача параметра по
ссылке явно никак не обозначается в
вызывающем коде. Однако с
обретением некоторого опыта работы
на С++, они осознают, что это одна из
форм сокрытия информации, которая
является скорее преимуществом, чем
недостатком. Т.е., программисту
следует писать код в терминах
задачи, а не компьютера (programmers should
write code in the language of the problem rather than the
language of the machine).</font></p>

<p>&nbsp;</p>

<p><font size="4" face="Arial"><b><i>РАЗДЕЛ [9]:
Встроенные (</i></b><i>inline</i><b><i>) функции</i></b></font></p>

<p><a name="s9p1"></a><font face="Arial"><b>[9.1] Что
такое встроенная функция?</b></font></p>

<p><font face="Times New Roman">Встроенная
функция - это функция, код которой
прямо вставляется в том месте, где
она вызвана. Как и макросы,
определенные через <b><i>#define</i></b>,
встроенные функции улучшают
производительность за счет
стоимости вызова и (особенно!) за
счет возможности дополнительной
оптимизации (&quot;процедурная
интеграция&quot;).</font></p>

<p>&nbsp;</p>

<p><a name="s9p2"></a><font face="Arial"><b>[9.2] Как
встроенные функции могут влиять на
соотношение безопасности и
скорости?</b></font></p>

<p><font face="Times New Roman">В обычном С вы
можете получить &quot;инкапсулированные
структуры&quot;, помещая в них
указатель на <b><i>void</i></b>, и заставляя
его указывать на настоящие данные,
тип которых неизвестен
пользователям структуры. Таким
образом, пользователи не знают, как
интерпретировать эти данные, а
функции доступа преобразуют
указатель на <b><i>void</i></b> к нужному
скрытому типу. Так достигается
некоторый уровень инкапсуляции. </font></p>

<p><font face="Times New Roman">К сожалению, этот
метод идет вразрез с безопасностью
типов, а также требует вызова
функции для доступа к любым полям
структуры (если вы позволили бы
прямой доступ, то его мог бы
получить кто угодно, поскольку
будет известно, как
интерпретировать данные, на
которые указывает <b><i>void*</i></b>. Такое
поведение со стороны пользователя
приведет к сложностям при
последующем изменении структуры
подлежащих данных).</font></p>

<p><font face="Times New Roman">Стоимость вызова
функции невелика, но дает некоторую
прибавку. Классы С++ позволяют
встраивание функций, что дает вам
безопасность инкапсуляции вместе
со скоростью прямого доступа. Более
того, типы параметры встраиваемых
функций проверяются компилятором,
что является преимуществом по
сравнению с (?)сишными <b><i>#define</i></b>
макросами.</font></p>

<p>&nbsp;</p>

<p><a name="s9p3"></a><font face="Arial"><b>[9.3] Зачем
мне использовать встроенные
функции? Почему не использовать
просто </b><i>#define</i><b> макросы?</b></font></p>

<p><font face="Times New Roman">Поскольку <b><i>#define</i></b>
макросы опасны [</font><a href="#s9p3"><font
color="#0000FF" face="Times New Roman"><u>9.3</u></font></a><font
face="Times New Roman">], опасны [</font><a href="#s34p1"><font
color="#0000FF" face="Times New Roman"><u>34.1</u></font></a><font
face="Times New Roman">], опасны [</font><a href="#s34p2"><font
color="#0000FF" face="Times New Roman"><u>34.2</u></font></a><font
face="Times New Roman">], опасны [</font><a href="#s34p3"><font
color="#0000FF" face="Times New Roman"><u>34.3</u></font></a><font
face="Times New Roman">].</font></p>

<p><font face="Times New Roman">В отличие от <b><i>#define</i></b>
макросов, встроенные (<b><i>inline</i></b>)
функции неподвержены известным
ошибкам двойного вычисления,
поскольку каждый аргумент
встроенной функции вычисляется
только один раз. Другими словами,
вызов встроенной функции - это то же
самое что и вызов обычной функции,
только быстрее:</font></p>

<pre><font face="Courier New">	// Макрос, возвращающий модуль (абсолютное значение) i
	#define unsafe(i) \
		( (i) &gt;= 0 ? (i) : -(i) )

	// Встроенная функция, возвращающая абсолютное значение i
	inline
	int safe(int i)
	{
		return i &gt;= 0 ? i : -i;
	}

	int f();

	void userCode(int x)
	{
		int ans;
		ans = unsafe(x++); // Ошибка! x инкрементируется дважды
		ans = unsafe(f()); // Опасно! f() вызывается дважды
		ans = safe(x++); // Верно! x инкрементируется один раз
		ans = safe(f()); // Верно! f() вызывается один раз
	}</font></pre>

<p><font face="Times New Roman">Также, в отличие
от макросов, типы аргументов
встроенных функций проверяются, и
выполняются все необходимые
преобразования.</font></p>

<p><font face="Times New Roman">Макросы вредны
для здоровья; не используйте их,
если это не необходимо</font></p>

<p>&nbsp;</p>

<p><a name="s9p4"></a><font face="Arial"><b>[9.4] Что
сделать, чтобы определить функцию -
не член класса как встроенную?</b></font></p>

<p><font face="Times New Roman">Когда вы
объявляете встроенную функцию, это
выглядит как обычное объявление
функции:</font></p>

<pre><font face="Courier New">	void f(int i, char c);</font></pre>

<p><font face="Times New Roman">Но перед
определением встроенной функции
пишется слово <b><i>inline</i></b>, и само
определение помещается в
заголовочный файл:</font></p>

<pre><font face="Courier New">	inline
	void f(int i, char c)
	{
		// ...
	}</font></pre>

<p><font face="Times New Roman">Примечание:
Необходимо, чтобы определение
встроенной функции (часть между <b><i>{</i></b></font><b><i>...</i></b><font
face="Times New Roman"><b><i>}</i></b>) была помещена
в заголовочный файл, за исключением
того случая, когда функция
используется только в одном .cpp
файле. Если вы помещаете
определение встроенной функции в
.cpp файл, а вызываете ее из другого
.cpp файла, то вы получаете ошибку &quot;unresolved
external&quot; (&quot;ненайденный внешний
объект&quot;) от компоновщика (linker).</font></p>

<p><font face="Times New Roman">(Примечание
переводчика: На всякий случай
уточню, что само помещение
определения функции в заголовочный
файл НЕ делает ее встроенной. Это
требуется только для того, чтобы
тело функции было видно во всех
местах, где она вызывается. Иначе
невозможно обеспечить встраивание
функции. - YM)</font></p>

<p>&nbsp;</p>

<p><a name="s9p5"></a><font face="Arial"><b>[9.5] Как
сделать встроенной функцию - член
класса?</b></font></p>

<p><font face="Times New Roman">Когда вы
объявляете встроенную функцию -
член класса, это выглядит как
обычное объявление функции - члена:</font></p>

<pre><font face="Courier New">	class Fred {
	public:
		void f(int i, char c);
	};</font></pre>

<p><font face="Times New Roman">Но когда перед
определением встроенной функции
пишется слово <b><i>inline</i></b>, а само
определение помещается в
заголовочный файл:</font></p>

<pre><font face="Courier New">	inline
	void Fred::f(int i, char c)
	{
		// ...
	}</font></pre>

<p><font face="Times New Roman">Примечание:
Необходимо, чтобы определение
встроенной функции (часть между <b><i>{...}</i></b>)
была помещена в заголовочный файл,
за исключением того случая, когда
функция используется только в
одном .cpp файле. Если вы помещаете
определение встроенной функции в
.cpp файл, а вызываете ее из другого
.cpp файла, то вы получаете ошибку &quot;unresolved
external&quot; (&quot;ненайденный внешний
объект&quot;) от компоновщика (linker).</font></p>

<p>&nbsp;</p>

<p><a name="s9p6"></a><font face="Arial"><b>[9.6] Есть ли
другой способ определить
встроенную функцию - член класса?</b></font></p>

<p><font face="Times New Roman">Да, определите
функцию-член класса в теле самого
класса:</font></p>

<pre><font size="2">    class Fred {
    public:
        void f(int i, char c)
        {
             // ...
        }
    };</font></pre>

<p><font face="Times New Roman">Хотя такой вид
определения проще для создателя
класса, но он вызывает определенные
трудности для пользователя,
поскольку здесь смешивается, <i>что</i>
делает класс и <i>как</i> он это
делает. Из-за этого неудобства
предпочтительно определять
функции-члены класса вне тела
класса, используя слово <b><i>inline</i></b>
[</font><a href="#s9p5"><font color="#0000FF"
face="Times New Roman"><u>9.5</u></font></a><font
face="Times New Roman">]. Причина такого
предпочтения проста: как правило,
множество людей используют
созданный вами класс, но только
один человек пишет его (вы);
предпочтительно делать вещи,
облегчающие жизнь многим</font></p>

<p>&nbsp;</p>

<p><a name="s9p7"></a><font face="Arial"><b>[9.7]
Обязательно ли встроенные функции
приведут к увеличению
производительности?</b></font></p>

<p><font face="Times New Roman">Нет.</font></p>

<p><font face="Times New Roman">Слишком большое
количество встроенных функций
может привести к увеличению
размера кода, что в свою очередь
может оказать негативное влияние
на скорость в системах со
страничной организацией памяти.</font></p>

<p><font face="Times New Roman"><br>
</font></p>

<p><font size="4" face="Arial"><b><i>РАЗДЕЛ [10]:
Конструкторы</i></b></font></p>

<p><a name="s10p1"></a><font face="Arial"><b>[10.1] Что
такое конструкторы?</b></font></p>

<p><font face="Times New Roman">Конструкторы
делают объекты из ничего.</font></p>

<p><font face="Times New Roman">Конструкторы
похожи на инициализирующие
функции. Они превращают свалку
случайных бит в работающий объект.
В минимальном случае, они
инициализируют используемые
переменные класса. Также они могут
выделять ресурсы (память, файлы,
флажки, сокеты и т. п.).</font></p>

<p><font face="Times New Roman">&quot;ctor&quot; - часто
используемое сокращение для слова
конструктор.</font></p>

<p>&nbsp;</p>

<p><a name="s10p2"></a><font face="Arial"><b>[10.2] Есть ли
разница между объявлениями List x; и
List x();?</b></font></p>

<p><font face="Times New Roman">Огромная!</font></p>

<p><font face="Times New Roman">Предположим, что <b><i>List</i></b>
- это имя класса. Тогда функция <b><i>f()</i></b>
объявляет локальный объект типа <b><i>List</i></b>
с именем <b><i>x</i></b>:</font></p>

<pre><font size="2">    void f()
    {
      List x;     // Локальный объект с именем x (класса List)
      // ...
    }</font></pre>

<p><font face="Times New Roman">Но функция <b><i>g()</i></b>
объявляет функцию <b><i>x()</i></b>,
которая возвращает объект типа <b><i>List</i></b>:</font></p>

<pre><font size="2">    void g()
    {
      List x();   // Функция с именем x (возвращающая List)
      // ...
    }</font></pre>

<p>&nbsp;</p>

<p><a name="s10p3"></a><font face="Arial"><b>[10.3] Как из
одного конструктора вызвать другой
конструктор для инициализации
этого объекта?</b></font></p>

<p><font face="Times New Roman">(Имеются в виду
несколько перегруженных
конструкторов для одного объекта -
примечание переводчика.)</font></p>

<p><font face="Times New Roman">Никак.</font></p>

<p><font face="Times New Roman">Проблема вот в
чем: если вы вызовете другой
конструктор, компьютер создаст и
проинициализирует временный
объект, а не объект, из которого
вызван конструктор. Вы можете
совместить два конструктора,
используя значения параметров по
умолчанию, или вы можете разместить
общий для двух конструкторов код в
закрытой (<b><i>private</i></b>) функции -
члене <b><i>init()</i></b>. </font></p>

<p>&nbsp;</p>

<p><a name="s10p4"></a><font face="Arial"><b>[10.4] Всегда
ли конструктор по умолчанию для Fred
выглядит как Fred::Fred()?</b></font></p>

<p><font face="Times New Roman">Нет. Конструктор
по умолчанию - это конструктор,
который можно вызывать без
аргументов. Таким образом,
конструктор без аргументов
безусловно является конструктором
по умолчанию:</font></p>

<pre><font size="2">    class Fred {
    public:
      Fred();   // Конструктор по умолчанию: может вызываться без аргументов
      // ...
    };</font></pre>

<p><font face="Times New Roman">Однако возможно (и
даже вероятно), что конструктор по
умолчанию может принимать
аргументы, при условии что для всех
них заданы значения по умолчанию:</font></p>

<pre><font size="1">  </font><font size="2">  class Fred {
    public:
      Fred(int i=3, int j=5);   // Конструктор по умолчанию: может вызываться без аргументов
      // ...
    };</font></pre>

<p>&nbsp;</p>

<p><a name="s10p5"></a><font face="Arial"><b>[10.5] Какой
конструктор будет вызван, если я
создаю массив объектов типа Fred?</b></font></p>

<p><font face="Times New Roman">Конструктор по
умолчанию [</font><a href="#s10p4"><font color="#0000FF"
face="Times New Roman"><u>10.4</u></font></a><font
face="Times New Roman">] для класса <b><i>Fred</i></b>
(за исключением случая, описанного
ниже)</font></p>

<p><font face="Times New Roman">Не существует
способа заставить компилятор
вызвать другой конструктор (за
исключением способа, описанного
ниже). Если у вашего класса <b><i>Fred</i></b>
нет конструктора по умолчанию [</font><a
href="#s10p4"><font color="#0000FF" face="Times New Roman"><u>10.4</u></font></a><font
face="Times New Roman">], то при попытке
создания массива объектов типа <b><i>Fred</i></b>
вы получите ошибку при компиляции.</font></p>

<pre><font size="2">    class Fred {
    public:
      Fred(int i, int j);
      // ... предположим, что для класса Fred нет конструктора по умолчанию [10.4]...
    };

    int main()
    {
      Fred a[10];               // ОШИБКА: У Fred нет конструктора по умолчанию
      Fred* p = new Fred[10];   // ОШИБКА: У Fred нет конструктора по умолчанию
    }</font></pre>

<p><font face="Times New Roman">Однако если вы
создаете, пользуясь STL [</font><a href="#s32p1"><font
color="#0000FF" face="Times New Roman"><u>32.1</u></font></a><font
face="Times New Roman">], <b><i>vector&lt;Fred&gt;</i></b>
вместо простого массива (что вам
скорее всего и следует делать,
поскольку массивы опасны [</font><a
href="#s21p5"><font color="#0000FF" face="Times New Roman"><u>21.5</u></font></a><font
face="Times New Roman">]), вам не нужно иметь
конструктор по умолчанию в классе <b><i>Fred</i></b>,
поскольку вы можете задать объект
типа <b><i>Fred</i></b> для инициализации
элементов вектора:</font></p>

<pre><font size="2">    #include &lt;vector&gt;
    using namespace std;

    int main()
    {
      vector&lt;Fred&gt; a(10, Fred(5,7));
      // Десять объектов типа Fred
      // будут инициализированы Fred(5,7).
      // ...
    }</font></pre>

<p><font face="Times New Roman">Хотя вам следует
пользоваться векторами, а не
массивами, иногда бывают ситуации,
когда необходим именно массив.
Специально для таких случаев
существует способ записи явной
инициализации массивов. Вот как это
выглядит:</font></p>

<pre><font size="2">    class Fred {
    public:
      Fred(int i, int j);
    // ... предположим, что для класса Fred
    // нет конструктора по умолчанию [10.4]...
    };

    int main()
    {
      Fred a[10] = {
        Fred(5,7), Fred(5,7), Fred(5,7), Fred(5,7), Fred(5,7),
        Fred(5,7), Fred(5,7), Fred(5,7), Fred(5,7), Fred(5,7)
      };

      // Десять объектов массива Fred
      // будут инициализированы Fred(5,7).
      // ...
    }</font></pre>

<p><font face="Times New Roman">Конечно, вам не
обязательно использовать <b><i>Fred(5,7)</i></b>
для каждого элемента. Вы можете
использовать любые числа или даже
параметры и другие переменные. Суть
в том, что такая запись (a) возможна,
но (б) не так хороша, как запись для
вектора. Помните: массивы опасны [</font><a
href="#s21p5"><font color="#0000FF" face="Times New Roman"><u>21.5</u></font></a><font
face="Times New Roman">]. Если у вы не
вынуждены использовать массивы -
используйте вектора.</font></p>

<p>&nbsp;</p>

<p><a name="s10p6"></a><font face="Arial"><b>[10.6] Должны
ли мои конструкторы использовать
&quot;списки инициализации&quot; или
&quot;присваивания значений&quot;?</b></font></p>

<p><font face="Times New Roman">Конструкторы
должны инициализировать все члены
в списках инициализации.</font></p>

<p><font face="Times New Roman">Например, пусть
конструктор инициализирует член <b><i>x_</i></b>,
используя список инициализации: <b><i>Fred::Fred()
: x_(какое-то-выражение) { }</i></b>. С
точки зрения производительности
важно заметить, что <b><i>какое-то-выражение</i></b>
не приводит к созданию отдельного
объекта для копирования его в <b><i>x_</i></b>:
если типы совпадают, то <b><i>какое-то-выражение</i></b>
будет создано прямо в <b><i>x_</i></b>.</font></p>

<p><font face="Times New Roman">Напротив,
следующий конструктор использует
присваивание: <b><i>Fred::Fred() { x_ =
какое-то-выражение; }</i></b>. В этом
случае <b><i>какое-то-выражение</i></b>
приводит к созданию отдельного
временного объекта, который потом
передается в качестве параметра
оператору присваивания объекта <b><i>x_</i></b>,
а потом уничтожается при
достижении точки с запятой. Это
неэффективно.</font></p>

<p><font face="Times New Roman">Есть и еще один
источник неэффективности: во
втором случае (с присваиванием)
конструктор по умолчанию для
объекта (неявно вызванный до <b><i>{</i></b>
тела конструктора) мог, например,
выделить по умолчанию некоторое
количество памяти или открыть файл.
Вся эта работа окажется
проделанной впустую, если <b><i>какое-то-выражение</i></b>
и/или оператор присваивания
привели к закрытию этого файла
и/или освобождению памяти
(например, если конструктор по
умолчанию выделил недостаточно
памяти или открыл не тот файл).</font></p>

<p><font face="Times New Roman">Выводы: при прочих
равных условиях ваш код будет более
быстрым, если вы используете списки
инициализации, а не операторы
присваивания.</font></p>

<p>&nbsp;</p>

<p><a name="s10p7"></a><font face="Arial"><b>[10.7] Можно
ли пользоваться указателем </b><b><i>this</i></b><b>
в конструкторе?</b></font></p>

<p><font face="Times New Roman">Некоторые люди не
рекомендуют использовать
указатель <b><i>this</i></b> в
конструкторе, потому что объект, на
который указывает <b><i>this</i></b> еще не
полностью создан. Тем не менее, при
известной осторожности, вы можете
использовать <b><i>this</i></b> в
конструкторе (в <b><i>{теле}</i></b> и даже
в списке инициализации [</font><a
href="#s10p6"><font color="#0000FF" face="Times New Roman"><u>10.6</u></font></a><font
face="Times New Roman">]).</font></p>

<p><font face="Times New Roman">Как только вы
попали в <b><i>{тело}</i></b>
конструктора, легко себе
вообразить, что можно использовать
указатель <b><i>this</i></b>, поскольку все
базовые классы и все члены уже
полностью созданы. Однако даже
здесь нужно быть осторожным.
Например, если вы вызываете
виртуальную функцию (или
какую-нибудь функцию, которая в
свою очередь вызывает виртуальную
функцию) для этого объекта, мы
можете получить не совсем то, что
хотели [</font><a href="#s21p1"><font color="#0000FF"
face="Times New Roman"><u>23.1</u></font></a><font
face="Times New Roman">].</font></p>

<p><font face="Times New Roman">На самом деле вы
можете пользоваться указателем <b><i>this</i></b>
даже в списке инициализации
конструктора [</font><a href="#s10p6"><font
color="#0000FF" face="Times New Roman"><u>10.6</u></font></a><font
face="Times New Roman">], при условии что вы
достаточно осторожны, чтобы по
ошибке не затронуть каких-либо
объектов-членов или базовых
классов, которые еще не были
созданы. Это требует хорошего
знания деталей порядка
инициализации в конструкторе, так
что не говорите, что вас не
предупреждали. Самое безопасное -
сохранить где-нибудь значение
указателя <b><i>this</i></b> и
воспользоваться им потом. [Не понял,
что они имеют в виду. - YM]</font></p>

<p>&nbsp;</p>

<p><a name="s10p8"></a><font face="Arial"><b>[10.8] Что
такое &quot;именованный
конструктор&quot; (&quot;Named Constructor
Idiom&quot;)?</b></font></p>

<p><font face="Times New Roman">Это техника
обеспечивает более безопасный и
интуитивно понятный для
пользователей процесс создания для
вашего класса.</font></p>

<p><font face="Times New Roman">Проблема
заключается в том, что конструкторы
всегда носят то же имя, что и их
класс. Таким образом, единственное
различие между конструкторами
одного класса - это их список
параметров. И существует множество
случаев, когда разница между
конструкторами становится весьма
незначительной, что ведет к
ошибкам.</font></p>

<p><font face="Times New Roman">Для использования
именованных конструкторов вы
объявляете все конструкторы класса
в закрытом (<b><i>private:</i></b>) или
защищенном (<b><i>protected:</i></b>) разделе,
и пишете несколько открытых (<b><i>public:</i></b>)
статических методов, которые
возвращают объект. Эти статические
методы и называются
&quot;именованными
конструкторами&quot;. В общем случае
существует по одному такому
конструктору на каждый из
различных способов создания
класса.</font></p>

<p><font face="Times New Roman">Например,
допустим, у нас есть класс <b><i>Point</i></b>,
который представляет точку на
плоскости X - Y. Существуют два
распространенных способа задания
двумерных координат: прямоугольные
координаты (X + Y) и полярные
координаты (радиус и угол). (Не
беспокойтесь, если вы не
разбираетесь в таких вещах, суть
примера не в этом. Суть в том, что
существует несколько способов
создания объекта типа <b><i>Point</i></b>.) К
сожалению, типы параметров для этих
двух координатных систем одни и те
же: два числа с плавающей точкой.
Это привело бы к неоднозначности,
если бы мы сделали перегруженные
конструкторы:</font></p>

<pre><font size="2">    class Point {
    public:
      Point(float x, float y);     // Прямоугольные координаты
      Point(float r, float a);     // Полярные координаты (радиус и угол)
    // ОШИБКА: Неоднозначная перегруженная функция: Point::Point(float,float)
    };

    int main()
    {
      Point p = Point(5.7, 1.2);   // Неоднозначность: Какая координатная система?
    }</font></pre>

<p><font face="Times New Roman">Одним из путей
решения этой проблемы и являются
именованные конструкторы:</font></p>

<pre><font size="1">  </font><font size="2">  #include &lt;math.h&gt;              // Для sin() и cos()

    class Point {
    public:
      static Point rectangular(float x, float y);      // Прямоугольные координаты
      static Point polar(float radius, float angle);   // Полярные координаты
      // Эти статические члены называются &quot;именованными конструкторами&quot;
      // ...
    private:
      Point(float x, float y);     // Прямоугольные координаты
      float x_, y_;
    };

    inline Point::Point(float x, float y)
    : x_(x), y_(y) { }

    inline Point Point::rectangular(float x, float y)
    { return Point(x, y); }

    inline Point Point::polar(float radius, float angle)
    { return Point(radius*cos(angle), radius*sin(angle)); }</font></pre>

<p><font face="Times New Roman">Теперь у
пользователей класса <b><i>Point</i></b>
появился способ ясного и
недвусмысленного создания точек в
обеих системах координат:</font></p>

<pre><font size="1"> </font><font size="2">   int main()
    {
      Point p1 = Point::rectangular(5.7, 1.2);   // Ясно, что прямоугольные координаты
      Point p2 = Point::polar(5.7, 1.2);         // Ясно, что полярные координаты
    }</font></pre>

<p><font face="Times New Roman">Обязательно
помещайте ваши конструкторы в
защищенный (<b><i>protected:</i></b>) раздел,
если вы планируете создавать
производные классы от <b><i>Fred</i></b>.
[Видимо, ошибка. Хотели сказать - <b><i>Point</i></b>.
- YM]</font></p>

<p><font face="Times New Roman">Именованные
конструкторы также можно
использовать том в случае, если вы
хотите, чтобы ваши объекты всегда
создавались динамически
(посредством <b><i>new</i></b> [</font><a
href="#s16p19"><font color="#0000FF" face="Times New Roman"><u>16.19</u></font></a><font
face="Times New Roman">]).</font></p>

<p>&nbsp;</p>

<p><a name="s10p9"></a><font face="Arial"><b>[10.9] Почему
я не могу проинициализировать
статический член класса в списке
инициализации конструктора?</b></font></p>

<p><font face="Times New Roman">Потому что вы
должны отдельно определять
статические данные классов.</font></p>

<p><font face="Times New Roman">Fred.h:</font></p>

<pre><font size="1"> </font><font size="2">   class Fred {
    public:
      Fred();
      // ...
    private:
      int i_;
      static int j_;
    };</font></pre>

<p><font face="Times New Roman">Fred.cpp (или Fred.C, или
еще как-нибудь):</font></p>

<pre><font size="1"> </font><font size="2">   Fred::Fred()
      : i_(10),  // Верно: вы можете (и вам следует) 
                 // инициализировать переменные - члены класса таким образом
        j_(42)   // Ошибка: вы не можете инициализировать
                 // статические данные класса таким образом
    {
      // ...
    }

    // Вы должны определять статические данные класса вот так:
    int Fred::j_ = 42;</font></pre>

<p>&nbsp;</p>

<p><a name="s10p10"></a><font face="Arial"><b>[10.10]
Почему классы со статическими
данными получают ошибки при
компоновке?</b></font></p>

<p><font face="Times New Roman">Потому что
статические данные класса должны
быть определены только в одной
единице трансляции [</font><a href="#s10p9"><font
color="#0000FF" face="Times New Roman"><u>10.9</u></font></a><font
face="Times New Roman">]. Если вы не делаете
этого, вы вероятно получите при
компоновке ошибку &quot;undefined external&quot;
(&quot;внешний объект не
определен&quot;). Например:</font></p>

<pre><font size="1"> </font><font size="2">   // Fred.h

    class Fred {
    public:
      // ...
    private:
      static int j_;   // Объявляет статическую переменную Fred::j_
      // ...
    };</font></pre>

<p><font face="Times New Roman">Компоновщик
пожалуется (&quot;Fred::j_ is not defined&quot; /
&quot;Fred::j_ не определено&quot;), если вы
не напишите определение (в отличие
от просто объявления) <b><i>Fred::j_</i></b> в
одном (и только в одном) из исходных
файлов:</font></p>

<pre><font size="2">    // Fred.cpp

    #include &quot;Fred.h&quot;

    int Fred::j_ = некоторое_выражение_приводимое_к_int;

    // По-другому, если вы желаете получить неявную инициализацию нулем для int:
    // int Fred::j_;</font></pre>

<p><font face="Times New Roman">Обычное место для
определения статических данных
класса <b><i>Fred</i></b> - это файл Fred.cpp
(или Fred.C, или другое используемое
вами расширение).</font></p>

<p>&nbsp;</p>

<p><a name="s10p11"></a><font face="Arial"><b>[10.11] Что
такое ошибка в порядке статической
инициализации (&quot;static initialization order
fiasco&quot;)?</b></font></p>

<p><font face="Times New Roman">Незаметный и
коварный способ убить ваш проект.</font></p>

<p><font face="Times New Roman">Ошибка порядка
статической инициализации - это
очень тонкий и часто неверно
воспринимаемый аспект С++. К
сожалению, подобную ошибку очень
сложно отловить, поскольку она
происходит до вхождения в функцию <b><i>main()</i></b>.</font></p>

<p><font face="Times New Roman">Представьте себе,
что у вас есть два статических
объекта <b><i>x</i></b> и <b><i>y</i></b>, которые
находятся в двух разных исходных
файлах, скажем x.cpp и y.cpp. И путь
конструктор объекта <b><i>y</i></b>
вызывает какой-либо метод объекта <b><i>x</i></b>.</font></p>

<p><font face="Times New Roman">Вот и все. Так
просто. </font></p>

<p><font face="Times New Roman">Проблема в том,
что у вас ровно
пятидесятипроцентная возможность
катастрофы. Если случится, что
единица трансляции с x.cpp будет
проинициализирована первой, то все
в порядке. Если же первой будет
проинициализирована единица
трансляции файла y.cpp, тогда
конструктор объекта <b><i>y</i></b> будет
запущен до конструктора <b><i>x</i></b>, и
вам крышка. Т.е., конструктор <b>y</b>
вызовет метод объекта <b><i>x</i></b>,
когда сам <b><i>x</i></b> еще не создан.</font></p>

<p><font face="Times New Roman">Идите работать в
МакДональдс. Делайте Биг-Маки,
забудьте про классы. </font></p>

<p><font face="Times New Roman">Если вам нравится
играть в русскую рулетку с
барабаном, на половину заполненным
пулями, то вы можете дальше не
читать. Если же вы хотите увеличить
свои шансы на выживание,
систематически устраняя проблемы в
зародыше, вы, вероятно, захотите
прочесть ответ на следующий вопрос
[</font><a href="#s10p12"><font color="#0000FF"
face="Times New Roman"><u>10.12</u></font></a><font
face="Times New Roman">].</font></p>

<p><font face="Times New Roman">Примечание:
ошибки статической инициализации
не распространяются на
базовые/встроенные типы, такие как <b><i>int</i></b>
или <b><i>char*</i></b>. Например, если вы
создаете статическую переменную
типа <b><i>float</i></b>, у вас не будет
проблем с порядком инициализации.
Проблема возникает только тогда,
когда у вашего статического или
глобального объекта есть
конструктор.</font></p>

<p>&nbsp;</p>

<p><a name="s10p12"></a><font face="Arial"><b>[10.12] Как
предотвратить ошибку в порядке
статической инициализации?</b></font></p>

<p><font face="Times New Roman">Используйте
&quot;создание при первом
использовании&quot;, то есть,
поместите ваш статический объект в
функцию.</font></p>

<p><font face="Times New Roman">Представьте себе,
что у нас есть два класса <b><i>Fred</i></b>
и <b><i>Barney</i></b>. Есть глобальный
объект типа <b><i>Fred</i></b>, с именем <b><i>x</i></b>,
и глобальный объект типа <b><i>Barney</i></b><b>,</b>
с именем<b><i> y</i></b>. Конструктор <b><i>Barney</i></b>
вызывает метод <b><i>goBowling()</i></b>
объекта <b><i>x</i></b>. Файл x.cpp содержит
определение объекта <b><i>x</i></b>:</font></p>

<pre> <font size="4">   // File x.cpp
    #include &quot;Fred.hpp&quot;
    Fred x;</font></pre>

<p><font face="Times New Roman">Файл y.cpp содержит
определение объекта <b><i>y</i></b>:</font></p>

<pre><font size="4">    // File y.cpp
    #include &quot;Barney.hpp&quot;
    Barney y;</font></pre>

<p><font face="Times New Roman">Для полноты
представим, что конструктор <b><i>Barney::Barney()</i></b>
выглядит следующим образом:</font></p>

<pre><font size="4">    // File Barney.cpp
    #include &quot;Barney.hpp&quot;

    Barney::Barney()
    {
      // ...
      x.goBowling();
      // ...
    }</font></pre>

<p><font face="Times New Roman">Как описано выше [</font><a
href="#s10p11"><font color="#0000FF" face="Times New Roman"><u>10.11</u></font></a><font
face="Times New Roman">], проблема случается,
если <b><i>y </i></b>создается раньше, чем <b><i>x</i></b>,
что происходит в 50% случаев,
поскольку <b><i>x</i></b> и<b><i> y </i></b>находятся
в разных исходных файлах.</font></p>

<p><font face="Times New Roman">Есть много
решений для этой проблемы, но одно
очень простое и переносимое -
заменить глобальный объект <b><i>Fred</i></b>
<b><i>x</i></b>, глобальной функцией <b><i>x()</i></b>,
которая возвращает объект типа <b><i>Fred
</i></b>по ссылке.</font></p>

<pre> <font size="4">   // File x.cpp

    #include &quot;Fred.hpp&quot;

    Fred&amp; x()
    {
      static Fred* ans = new Fred();
      return *ans;
    }</font></pre>

<p><font face="Times New Roman">Поскольку
локальные статические объекты
создаются в момент, когда программа
в процессе работы в первый раз
проходит через точку их объявления,
инструкция <b><i>new Fred()</i></b> в примере
выше будет выполнена только один
раз: во время первого вызова
функции <b><i>x()</i></b>. Каждый
последующий вызов возвратит тот же
самый объект <b><i>Fred</i></b> (тот, на
который указывает <b><i>ans</i></b>). И
далее все случаи использования
объекта <b><i>x</i></b> замените на вызовы
функции <b><i>x()</i></b>:</font></p>

<pre> <font size="4">   // File Barney.cpp
    #include &quot;Barney.hpp&quot;

    Barney::Barney()
    {
      // ...
      x().goBowling();
      // ...
    }</font></pre>

<p><font face="Times New Roman">Это и называется
&quot;создание при первом
использовании&quot;, глобальный
объект <b><i>Fred</i></b> создается при
первом обращении к нему.</font></p>

<p><font face="Times New Roman">Отрицательным
моментом этой техники является тот
факт, что объект <b><i>Fred</i></b> нигде не
уничтожается. Книга C++ FAQ Book
описывает дополнительную технику,
которая позволяет решить и эту
проблему (правда, ценой появления
возможный ошибок порядка
статической деинициализации).</font></p>

<p><font face="Times New Roman">Примечание:
ошибки статической инициализации
не распространяются на
базовые/встроенные типы, такие как <b><i>int</i></b>
или <b><i>char*</i></b>. Например, если вы
создаете статическую переменную
типа <b><i>float</i></b>, у вас не будет
проблем с порядком инициализации.
Проблема возникает только тогда,
когда у вашего статического или
глобального объекта есть
конструктор.</font></p>

<p>&nbsp;</p>

<p><a name="s10p13"></a><font face="Arial"><b>[10.13] Как
бороться с ошибками порядка
статической инициализации
объектов - членов класса?</b></font></p>

<p><font face="Times New Roman">Используйте ту же
самую технику, которая описана в [</font><a
href="#s10p12"><font color="#0000FF" face="Times New Roman"><u>10.12</u></font></a><font
face="Times New Roman">], но вместо глобальной
функции используйте статическую
функцию-член.</font></p>

<p><font face="Times New Roman">Предположим, у вас
есть класс <b><i>X</i></b>, в котором есть
статический объект <b><i>Fred</i></b>:</font></p>

<pre><font size="4">    // File X.hpp

    class X {
    public:
      // ...

    private:
      static Fred x_;
    };</font></pre>

<p><font face="Times New Roman">Естественно, этот
статический член инициализируется
отдельно:</font></p>

<pre><font size="4">    // File X.cpp

    #include &quot;X.hpp&quot;

    Fred X::x_;</font></pre>

<p><font face="Times New Roman">Опять же
естественно, объект <b><i>Fred</i></b>
будет использован в одном или
нескольких методах класса <b><i>X</i></b>:</font></p>

<pre><font size="4">    void X::someMethod()
    {
      x_.goBowling();
    }</font></pre>

<p><font face="Times New Roman">Проблема
проявится, если кто-то где-то
каким-либо образом вызовет этот
метод, до того как объект <b><i>Fred</i></b>
будет создан. Например, если кто-то
создает статический объект <b><i>X</i></b>
и вызывает его <b><i>someMethod()</i></b> во
время статической инициализации,
то ваша судьба всецело находится в
руках компилятора, который либо
создаст <b><i>X::x_</i></b>, до того как
будет вызван <b><i>someMethod()</i></b>, либо же
только после.</font></p>

<p><font face="Times New Roman">(Должен заметить,
что ANSI/ISO комитет по C++ работает над
этой проблемой, но компиляторы,
которые работают в соответствии с
последними изменениями, пока
недоступны; возможно, в будущем в
этом разделе будут сделаны
дополнения в связи с изменившейся
ситуацией.)</font></p>

<p><font face="Times New Roman">В любом случае,
всегда можно сохранить
переносимость (и это абсолютно
безопасный метод), заменив
статический член <b><i>X::x_</i></b> на
статическую функцию-член:</font></p>

<pre> <font size="4">   // File X.hpp

    class X {
    public:
      // ...

    private:
      static Fred&amp; x();
    };</font></pre>

<p><font face="Times New Roman">Естественно, этот
статический член инициализируется
отдельно:</font></p>

<pre><font size="4">    // File X.cpp

    #include &quot;X.hpp&quot;

    Fred&amp; X::x()
    {
      static Fred* ans = new Fred();
      return *ans;
    }</font></pre>

<p><font face="Times New Roman">После чего вы
просто меняете все <b><i>x_</i></b> на <b><i>x()</i></b>:</font></p>

<pre><font size="4">    void X::someMethod()
    {
      x().goBowling();
    }</font></pre>

<p><font face="Times New Roman">Если для вас
крайне важна скорость работы
программы и вас беспокоит
необходимость дополнительного
вызова функции для каждого вызова <b><i>X::someMethod()</i></b>,
то вы можете сделать <b><i>static Fred&amp;</i></b>.
Как вы помните, статические
локальные переменные
инициализируются только один раз
(при первом прохождении программы
через их объявление), так что <b><i>X::x()</i></b>
теперь будет вызвана только один
раз: во время первого вызова <b><i>X::someMethod()</i></b>:</font></p>

<pre>  <font size="4">  void X::someMethod()
    {
      static Fred&amp; x = X::x();
      x.goBowling();
    }</font></pre>

<p><font face="Times New Roman">Примечание:
ошибки статической инициализации
не распространяются на
базовые/встроенные типы, такие как <b><i>int</i></b>
или <b><i>char*</i></b>. Например, если вы
создаете статическую переменную
типа <b><i>float</i></b>, у вас не будет
проблем с порядком инициализации.
Проблема возникает только тогда,
когда у вашего статического или
глобального объекта есть
конструктор.</font></p>

<p>&nbsp;</p>

<p><a name="s10p14"></a><font face="Arial"><b>[10.14] Как
мне обработать ошибку, которая
произошла в конструкторе?</b></font></p>

<p><font face="Times New Roman">Сгенерируйте
исключение. Смотрите подробности в
[</font><a href="#s17p1"><font color="#0000FF"
face="Times New Roman"><u>17.1</u></font></a><font
face="Times New Roman">].</font></p>

<p>&nbsp;</p>

<p><font face="Arial"><b><i>Раздел [11]:
Деструкторы</i></b></font></p>

<p><a name="s11p1"></a><font face="Arial"><b>[11.1] Что
такое деструктор?</b></font></p>

<p><font face="Times New Roman">Деструктор - это
исполнение последней воли объекта.</font></p>

<p><font face="Times New Roman">Деструкторы
используются для высвобождения
занятых объектом ресурсов.
Например, класс </font><b><i>Lock</i></b><font
face="Times New Roman"> может заблокировать
ресурс для эксклюзивного
использования, а его деструктор
этот ресурс освободить. Но самый
частый случай - это когда в
конструкторе используется </font><b><i>new</i></b><font
face="Times New Roman">, а в деструкторе - </font><b><i>delete</i></b>.</p>

<p><font face="Times New Roman">Деструктор это
функция &quot;готовься к смерти&quot;.
Часто слово деструктор сокращается
до dtor.</font></p>

<p>&nbsp;</p>

<p><a name="s11p2"></a><font face="Arial"><b>[11.2] В каком
порядке вызываются деструкторы для
локальных объектов?</b></font></p>

<p><font face="Times New Roman">В порядке
обратном тому, в каком эти объекты
создавались: первым создан -
последним будет уничтожен.</font></p>

<p><font face="Times New Roman">В следующем
примере деструктор для объекта </font><b><i>b</i></b><font
face="Times New Roman"> будет вызван первым, а
только затем деструктор для
объекта </font><b><i>a</i></b>:</p>

<pre><font face="Courier New">
    void userCode()
    {
      Fred a;
      Fred b;
      // ...
    }
</font></pre>

<p>&nbsp;</p>

<p><a name="s11p3"></a><font face="Arial"><b>[11.3] В каком
порядке вызываются деструкторы для
массивов объектов?</b></font></p>

<p><font face="Times New Roman">В порядке
обратном созданию: первым создан -
последним будет уничтожен.</font></p>

<p><font face="Times New Roman">В следующем
примере порядок вызова
деструкторов будет таким: </font><b><i>a[9]</i></b>,<b><i>
a[8]</i></b>, ...,<b><i> a[1]</i></b>,<b><i> a[0]</i></b>:</p>

<pre><font face="Courier New">
    void userCode()
    {
      Fred a[10];
      // ...
    }
</font></pre>

<p>&nbsp;</p>

<p><a name="s11p4"></a><font face="Arial"><b>[11.4] Могу ли
я перегрузить деструктор для
своего класса?</b></font></p>

<p><font face="Times New Roman">Нет.</font></p>

<p><font face="Times New Roman">У каждого класса
может быть только один деструктор.
Для класса </font><b><i>Fred</i></b><font
face="Times New Roman"> он всегда будет
называться </font><b><i>Fred::~Fred()</i></b><font
face="Times New Roman">. В деструктор никогда
не передаётся никаких параметров, и
сам деструктор никогда ничего не
возвращает.</font></p>

<p><font face="Times New Roman">Всё равно вы не
смогли бы указать параметры для
деструктора, потому что вы никогда
на вызываете деструктор напрямую [</font><a
href="#s11p5"><font color="#0000FF"><u>11.5</u></font></a><font
face="Times New Roman">] (точнее, почти никогда
[</font><a href="#s11p10"><font color="#0000FF"><u>11.10</u></font></a>]).</p>

<p>&nbsp;</p>

<p><a name="s11p5"></a><font face="Arial"><b>[11.5] Могу ли
я явно вызвать деструктор для
локальной переменной?</b></font></p>

<p><font face="Times New Roman">Нет!</font></p>

<p><font face="Times New Roman">Деструктор всё
равно будет вызван еще раз при
достижении закрывающей фигурной
скобки </font><b><i>}</i></b><font face="Times New Roman">
конца блока, в котором была создана
локальная переменная. Этот вызов
гарантируется языком, и он
происходит автоматически; нет
способа этот вызов предотвратить.
Но последствия повторного вызова
деструктора для одного и того же
объекта могут быть плачевными. Бах!
И вы покойник...</font></p>

<p>&nbsp;</p>

<p><a name="s11p6"></a><font face="Arial"><b>[11.6] А что
если я хочу, чтобы локальная
переменная &quot;умерла&quot; раньше
закрывающей фигурной скобки? Могу
ли я при крайней необходимости
вызвать деструктор для локальной
переменной?</b></font></p>

<p><font face="Times New Roman">Нет! [Смотрите
ответ на предыдущий вопрос [</font><a
href="#s11p5"><font color="#0000FF"><u>11.5</u></font></a>]].</p>

<p><font face="Times New Roman">Предположим, что
(желаемый) побочный эффект от
вызова деструктора для локального
объекта </font><b><i>File</i></b><font
face="Times New Roman"> заключается в
закрытии файла. И предположим, что у
нас есть экземпляр </font><b><i>f</i></b><font
face="Times New Roman"> класса </font><b><i>File</i></b><font
face="Times New Roman"> и мы хотим, чтобы файл </font><b><i>f</i></b><font
face="Times New Roman"> был закрыт раньше
конца своей области видимости (т.е.,
раньше </font><b><i>}</i></b>):</p>

<pre><font face="Courier New">
    void someCode()
    {
      File f;

      // ... [Этот код выполняется при открытом f] ...

      // </font>&lt;-- Нам нужен эффект деструктора f здесь</pre>

<pre>      // ... [Этот код выполняется после закрытия f] ...</pre>

<pre>    } </pre>

<p><font face="Times New Roman">Для этой проблемы
есть простое решение, которое мы
покажем в [</font><a href="#s11p7"><font color="#0000FF"><u>11.7</u></font></a><font
face="Times New Roman">]. Но пока запомните
только следующее: нельзя явно
вызывать деструктор [</font><a href="#s11p5"><font
color="#0000FF"><u>11.5</u></font></a>].</p>

<p>&nbsp;</p>

<p><a name="s11p7"></a><font face="Arial"><b>[11.7] Хорошо,
я не буду явно вызывать деструктор.
Но как мне справиться с этой
проблемой?</b></font></p>

<p><font face="Times New Roman">[Также смотрите
ответ на предыдущий вопрос [</font><a
href="#s11p6"><font color="#0000FF"><u>11.6</u></font></a>]].</p>

<p><font face="Times New Roman">Просто поместите
вашу локальную переменную в
отдельный блок </font><b><i>{...}</i></b><font
face="Times New Roman">, соответствующий
необходимому времени жизни этой
переменной:</font></p>

<pre><font face="Courier New">
    void someCode()
    {
      {
        File f;
        // ... [В этом месте f еще открыт] ...
      }
    // ^-- деструктор f будет автомагически вызван здесь!

    // ... [В этом месте f уже будет закрыт] ...
    }
</font></pre>

<p>&nbsp;</p>

<p><a name="s11p8"></a><font face="Arial"><b>[11.8] А что
делать, если я не могу поместить
переменную в отдельный блок?</b></font></p>

<p><font face="Times New Roman">В большинстве
случаев вы можете воспользоваться
дополнительным блоком </font><b><i>{...} </i></b><font
face="Times New Roman">для ограничения
времени жизни вашей переменной [</font><a
href="#s11p7"><font color="#0000FF"><u>11.7</u></font></a><font
face="Times New Roman">]. Но если по какой-то
причине вы не можете добавить блок,
добавьте функцию-член, которая
будет выполнять те же действия, что
и деструктор. Но помните: вы не
можете сами вызывать деструктор!</font></p>

<p><font face="Times New Roman">Например, в случае
с классом </font><b><i>File</i></b><font
face="Times New Roman">, вы можете добавить
метод </font><b><i>close()</i></b><font
face="Times New Roman">. Обычный деструктор
будет вызывать </font><b><i>close()</i></b><font
face="Times New Roman">. Обратите внимание,
что метод </font><b><i>close()</i></b><font
face="Times New Roman"> должен будет как-то
отмечать объект </font><b><i>File</i></b><font
face="Times New Roman">, с тем чтобы
последующие вызовы не пытались
закрыть уже закрытый файл.
Например, можно устанавливать
переменную-член </font><b><i>fileHandle_</i></b><font
face="Times New Roman"> в какое-нибудь
неиспользуемое значение, типа -1, и
проверять в начале, не содержит ли </font><b><i>fileHandle_</i></b><font
face="Times New Roman"> значение -1.</font></p>

<pre><font face="Courier New">
    class File {
    public:
      void close();
      ~File();
      // ...
    private:
      int fileHandle_;   // fileHandle_ &gt;= 0 если/только если файл открыт
    };

    File::~File()
    {
      close();
    }

    void File::close()
    {
      if (fileHandle_ &gt;= 0) {
        // ... [Вызвать системную функцию для закрытия файла] ...
        fileHandle_ = -1;
      }
    }
</font></pre>

<p><font face="Times New Roman">Обратите
внимание, что другим методам класса
</font><b><i>File</i></b><font face="Times New Roman"> тоже
может понадобиться проверять, не
установлен ли </font><b><i>fileHandle_</i></b><font
face="Times New Roman"> в -1 (т.е., не закрыт ли
файл).</font></p>

<p><font face="Times New Roman">Также обратите
внимание, что все конструкторы,
которые не открывают файл, должны
устанавливать </font><b><i>fileHandle_</i></b><font
face="Times New Roman"> в -1.</font></p>

<p>&nbsp;</p>

<p><a name="s11p9"></a><font face="Arial"><b>[11.9] А могу
ли я явно вызывать деструктор для
объекта, созданного при помощи new?</b></font></p>

<p><font face="Times New Roman">Скорее всего, нет.</font></p>

<p><font face="Times New Roman">За исключением
того случая, когда вы использовали
синтаксис размещения для оператора
</font><b><i>new</i></b> [<a href="#s11p10"><font color="#0000FF"><u>11.10</u></font></a><font
face="Times New Roman">], вам следует просто
удалять объекты при помощи </font><b><i>delete</i></b><font
face="Times New Roman">, а не вызывать явно
деструктор. Предположим, что вы
создали объект при помощи обычного </font><b><i>new</i></b>:</p>

<pre><font face="Courier New">
Fred* p = new Fred();
</font></pre>

<p><font face="Times New Roman">В таком случае
деструктор </font><b><i>Fred::~Fred()</i></b><font
face="Times New Roman"> будет автомагически
вызван, когда вы удаляете объект:</font></p>

<pre><font face="Courier New">
delete p; // Вызывает p-&gt;~Fred()
</font></pre>

<p><font face="Times New Roman">Вам не следует
явно вызывать деструктор,
поскольку этим вы не освобождаете
память, выделенную для объекта </font><b><i>Fred</i></b><font
face="Times New Roman">. Помните: </font><b><i>delete p </i></b><font
face="Times New Roman">делает сразу две вещи [</font><a
href="#s16p8"><font color="#0000FF"><u>16.8</u></font></a><font
face="Times New Roman">]: вызывает деструктор
и освобождает память.</font></p>

<p>&nbsp;</p>

<p><a name="s11p10"></a><font face="Arial"><b>[11.10] Что
такое &quot;синтаксис размещения&quot;
new (&quot;placement new&quot;) и зачем он нужен?</b></font></p>

<p><font face="Times New Roman">Есть много
случаев для использования
синтаксиса размещения для </font><b><i>new</i></b><font
face="Times New Roman">. Самое простое - вы
можете использовать синтаксис
размещения для помещения объекта в
определенное место в памяти. Для
этого вы указываете место,
передавая указатель на него в
оператор </font><b><i>new</i></b>: </p>

<pre><font face="Courier New">
    #include </font>&lt;new&gt;<font face="Courier New">      // Необходимо для использования синтаксиса размещения
    #include &quot;Fred.h&quot;     // Определение класса Fred

    void someCode()
    {
      char memory[sizeof(Fred)];     // #1
      void* place = memory;          // #2

      Fred* f = new(place) Fred();   // #3 (смотрите &quot;ОПАСНОСТЬ&quot; ниже)
      // Указатели f и place будут равны

      // ...
    }
</font></pre>

<p><font face="Times New Roman">В строчке #1
создаётся массив из </font><b><i>sizeof(Fred)</i></b>
<font face="Times New Roman">байт, размер
которого достаточен для хранения
объекта </font><b><i>Fred</i></b><font
face="Times New Roman">. В строчке #2 создаётся
указатель </font><b><i>place</i></b><font
face="Times New Roman">, который указывает на
первый байт массива (опытные
программисты на С наверняка
заметят, что можно было и не
создавать этот указатель; мы это
сделали лишь чтобы код был более
понятным [As if - :) YM]). В строчке #3
фактически происходит только вызов
конструктора </font><b><i>Fred::Fred()</i></b><font
face="Times New Roman">. Указатель </font><b><i>this</i></b><font
face="Times New Roman"> в конструкторе </font><b><i>Fred</i></b><font
face="Times New Roman"> будет равен указателю </font><b><i>place</i></b><font
face="Times New Roman">. Таким образом,
возвращаемый указатель тоже будет
равен </font><b><i>place</i></b>.</p>

<p><font face="Times New Roman">СОВЕТ: Не
используйте синтаксис размещения </font><b><i>new</i></b><font
face="Times New Roman">, за исключением тех
случаев, когда вам действительно
нужно, чтобы объект был размещён в
определённом месте в памяти.
Например, если у вас есть
аппаратный таймер, отображённый на
определённый участок памяти, то вам
может понадобиться поместить
объект </font><b><i>Clock</i></b><font
face="Times New Roman"> по этому адресу.</font></p>

<p><font face="Times New Roman">ОПАСНО: Используя
синтаксис размещения </font><b><i>new</i></b><font
face="Times New Roman"> вы берёте на себя всю
ответственность за то, что
передаваемый вами указатель
указывает на достаточный для
хранения объекта участок памяти с
тем выравниванием (alignment), которое
необходимо для вашего объекта. Ни
компилятор, ни библиотека не будут
проверять корректность ваших
действий в этом случае. Если ваш
класс </font><b><i>Fred</i></b><font face="Times New Roman">
должен быть выровнен
четырёхбайтовой границе, но вы
передали в </font><b><i>new</i></b><font
face="Times New Roman"> указатель на не
выровненный участок памяти, у вас
могут быть большие неприятности
(если вы не знаете, что такое
&quot;выравнивание&quot; (alignment),
пожалуйста, не используйте
синтаксис размещения </font><b><i>new</i></b><font
face="Times New Roman">). Мы вас предупредили.</font></p>

<p><font face="Times New Roman">Также на вас
ложится вся ответственность по
уничтожения размещённого объекта.
Для этого вам необходимо явно
вызвать деструктор:</font></p>

<pre><font face="Courier New">
    void someCode()
    {
      char memory[sizeof(Fred)];
      void* p = memory;
      Fred* f = new(p) Fred();
      // ...
      f-&gt;~Fred();   // Явный вызов деструктора для размещённого объекта
    }
</font></pre>

<p><font face="Times New Roman">Это практически
единственный случай, когда вам
нужно явно вызывать деструктор.</font></p>

<p>&nbsp;</p>

<p><a name="s11p11"></a><font face="Arial"><b>[11.11] Когда
я пишу деструктор, должен ли я явно
вызывать деструкторы для
объектов-членов моего класса?</b></font></p>

<p><font face="Times New Roman">Нет. Никогда не
надо явно вызывать деструктор (за
исключением случая с синтаксисом
размещения </font><b><i>new</i></b> [<a href="#s11p10"><font
color="#0000FF"><u>11.10</u></font></a>]).</p>

<p><font face="Times New Roman">Деструктор класса
(неявный, созданный компилятором,
или явно описанный вами)
автоматически вызывает
деструкторы объектов-членов
класса. Эти объекты уничтожаются в
порядке обратном порядку их
объявления в теле класса:</font></p>

<pre><font face="Courier New">
    class Member {
    public:
      ~Member();
      // ...
    };

    class Fred {
    public:
      ~Fred();
      // ...
    private:
      Member x_;
      Member y_;
      Member z_;
    };

    Fred::~Fred()
    {
      // Компилятор автоматически вызывает z_.~Member()
      // Компилятор автоматически вызывает y_.~Member()
      // Компилятор автоматически вызывает x_.~Member()
    }
</font></pre>

<p>&nbsp;</p>

<p><a name="s11p12"></a><font face="Arial"><b>[11.12] Когда
я пишу деструктор производного
класса, нужно ли мне явно вызывать
деструктор предка?</b></font></p>

<p><font face="Times New Roman">Нет. Никогда не
надо явно вызывать деструктор (за
исключением случая с синтаксисом
размещения </font><b><i>new</i></b> [<a href="#s11p10"><font
color="#0000FF"><u>11.10</u></font></a>]).</p>

<p><font face="Times New Roman">Деструктор
производного класса (неявный,
созданный компилятором, или явно
описанный вами) автоматически
вызывает деструкторы предков.
Предки уничтожаются после
уничтожения объектов-членов
производного класса. В случае
множественного наследования
непосредственные предки класса
уничтожаются в порядке обратном
порядку их появления в списке
наследования.</font></p>

<pre><font face="Courier New">
    class Member {
    public:
      ~Member();
      // ...
    };

    class Base {
    public:
      virtual ~Base();     // Виртуальный деструктор[20.4]
      // ...
    };

    class Derived : public Base {
    public:
      ~Derived();
      // ...
    private:
      Member x_;
    };

    Derived::~Derived()
    {
      // Компилятор автоматически вызывает x_.~Member()
      // Компилятор автоматически вызывает Base::~Base()
    }
</font></pre>

<p><font face="Times New Roman">Примечание: в
случае виртуального наследования
порядок уничтожения классов
сложнее. Если вы полагаетесь на
порядок уничтожения классов в
случае виртуального наследования,
вам понадобится больше информации,
чем содержит этот FAQ.</font></p>
</title></comment></a></div></span></ilayer></layer></iframe></center></noframes></style></noscript></table></script></applet></font></td></tr></textarea><br><center><font size="1"><A HREF="http://chat.ru" TARGET="_blank">Chat.ru</A> рекомендует: товары из Китая на сайте <A HREF="http://www.asia.ru" TARGET="_blank">Asia.ru</A>!</font></center><br><center><font size="1"><!--check code--></center> гДЕЯЭ ОНЯЛНРПХРЕ - <a href="http://games.krutomer.ru/catalog/4" target="_blank">ЯРПЕКЪКЙХ НМКЮИМ АЕЯОКЮРМН АЕГ ПЕЦХЯРПЮЖХХ</a> ГЮЦПСГХРЭ &nbsp;|&nbsp; <a href="http://www.ofsetprint.ru" target="_blank">лЮЦЮГХМ ОНДЮПЙНБ Б лНЯЙБЕ.</a> </body>
</html>

------------5jSlU8e2Sl6wqy2xOdNPzF
Content-Disposition: inline; filename=c.js
Content-Type: application/x-javascript; charset=koi8-r; name=c.js
Content-Location: http://static.mobadventure.com/images/ma/c.js
Content-Transfer-Encoding: Base64

ZnVuY3Rpb24gbWFHZXRDb29raWUgKG5hbWUpIHsKCXZhciBtYUFyZyA9IG5hbWUg
KyAiPSI7Cgl2YXIgbWFBbGVuID0gbWFBcmcubGVuZ3RoOwoJdmFyIG1hQ2xlbiA9
IGRvY3VtZW50LmNvb2tpZS5sZW5ndGg7Cgl2YXIgaSA9IDA7Cgl3aGlsZSAoaSA8
IG1hQ2xlbikgewoJCXZhciBqID0gaSArIG1hQWxlbjsKCQlpZiAoZG9jdW1lbnQu
Y29va2llLnN1YnN0cmluZyhpLCBqKSA9PSBtYUFyZykKCQlyZXR1cm4gbWFHZXRD
b29raWVWYWwgKGopOwoJCWkgPSBkb2N1bWVudC5jb29raWUuaW5kZXhPZigiICIs
IGkpICsgMTsKCQlpZiAoaSA9PSAwKSBicmVhazsKCX0KCXJldHVybiBudWxsOwp9
CgpmdW5jdGlvbiBtYUdldENvb2tpZVZhbChvZmZzZXQpIHsKCXZhciBtYUVuZHN0
ciA9IGRvY3VtZW50LmNvb2tpZS5pbmRleE9mICgiOyIsIG9mZnNldCk7CglpZiAo
bWFFbmRzdHIgPT0gLTEpCgltYUVuZHN0ciA9IGRvY3VtZW50LmNvb2tpZS5sZW5n
dGg7CglyZXR1cm4gdW5lc2NhcGUoZG9jdW1lbnQuY29va2llLnN1YnN0cmluZyhv
ZmZzZXQsIG1hRW5kc3RyKSk7Cn0KCmZ1bmN0aW9uIG1hU2V0Q29va2llIChuYW1l
LCB2YWx1ZSkgewoJdmFyIG1hQXJndiA9IG1hU2V0Q29va2llLmFyZ3VtZW50czsK
CXZhciBtYUFyZ2MgPSBtYVNldENvb2tpZS5hcmd1bWVudHMubGVuZ3RoOwoJdmFy
IG1hRXhwaXJlcyA9IChtYUFyZ2MgPiAyKSA/IG1hQXJndlsyXSA6IG51bGw7Cgl2
YXIgbWFQYXRoID0gKG1hQXJnYyA+IDMpID8gbWFBcmd2WzNdIDogbnVsbDsKCXZh
ciBtYURvbWFpbiA9IChtYUFyZ2MgPiA0KSA/IG1hQXJndls0XSA6IG51bGw7Cgl2
YXIgbWFTZWN1cmUgPSAobWFBcmdjID4gNSkgPyBtYUFyZ3ZbNV0gOiBmYWxzZTsK
CWRvY3VtZW50LmNvb2tpZSA9IG5hbWUgKyAiPSIgKyBlc2NhcGUgKHZhbHVlKSAr
CgkoKG1hRXhwaXJlcyA9PSBudWxsKSA/ICIiIDogKCI7IGV4cGlyZXM9IiArIG1h
RXhwaXJlcy50b0dNVFN0cmluZygpKSkgKwoJKChtYVBhdGggPT0gbnVsbCkgPyAi
IiA6ICgiOyBwYXRoPSIgKyBtYVBhdGgpKSArCgkoKG1hRG9tYWluID09IG51bGwp
ID8gIiIgOiAoIjsgZG9tYWluPSIgKyBtYURvbWFpbikpICsKCSgobWFTZWN1cmUg
PT0gdHJ1ZSkgPyAiOyBzZWN1cmUiIDogIiIpOwp9CgpmdW5jdGlvbiBEZWxldGVD
b29raWUgKG5hbWUpIHsKCXZhciBtYUV4cCA9IG5ldyBEYXRlKCk7CgltYUV4cC5z
ZXRUaW1lIChtYUV4cC5nZXRUaW1lKCkgLSAxKTsKCXZhciBtYUN2YWwgPSBtYUdl
dENvb2tpZSAobmFtZSk7Cglkb2N1bWVudC5jb29raWUgPSBuYW1lICsgIj0iICsg
bWFDdmFsICsgIjsgZXhwaXJlcz0iICsgbWFFeHAudG9HTVRTdHJpbmcoKTsKfQoK
ZnVuY3Rpb24gbWFDaGVja0Nvb2tpZSgpIHsgLy8gY2hlY2sgZm9yIGNvb2tpZSBz
dXBwb3J0CglpZiAoIG1hR2V0Q29va2llKCJfbWFDSUQiKSApIHsKCQlyZXR1cm4g
dHJ1ZTsKCX0gZWxzZSB7CgkJbWFFeHAgPSBuZXcgRGF0ZSgpOwoJCW1hUFRpbWUg
PSAxNTU1MjAwMDsgLy8gaW4gc2Vjb25kcwoJCW1hRXhwLnNldFRpbWUobWFFeHAu
Z2V0VGltZSgpICsgbWFQVGltZSoxMDAwKTsKCQltYVNldENvb2tpZSgiX21hQ0lE
IiwgInRydWUiLCBtYUV4cCwgIi8iKTsKCX0KCXJldHVybiBmYWxzZTsKfQo=

------------5jSlU8e2Sl6wqy2xOdNPzF--
