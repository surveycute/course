***Программа курса С++.***

День 1.	
Переменные, массивы, std::vector(сразу после массивов), циклы, указатели, ссылки, функции, перегрузка функций.
Потоки ввода/вывода. Манипуляторы и флаги.

POD-type.

При копировании, как набора байт, в другое место и обратно, получим то же самое.

Переменные бывают автоматические и статические.

Статические инициализируются один раз и имеют время жизни такое же, как время жизни программы.
Автоматическая - размещается на стеке, время жизни зависит от области видимости.

char, short, long(int), long long, float, double

указатель int* a; адрес в памяти. Инкремент указателя перемещает его на sizeof(type).
Бывает указатель 0. 

указатель на непрерывную область памяти. Массив значений.
int* a;
new
new []
delete
delete [] <--- устаревшая форма.

int* a = new int[100];

Многомерные массивы.
постоянного размера double[3][3];
С пропущенным размером double[][3];

-ручное управление памятью.
-Нужно следить и вовремя очистить.
-Нужно быть уверенным, что указатель инициализирован.
-Нужно проверять выход за диапазон.
-Нужно вручну расширять и сокращать, при изменении объема данных.

Гораздо безопаснее и удобнее
std::vector - абстракция массива.
Сам растет, сам сужается.
Сам себя удалит.
Проверка диапазона.
можно использовать со старым кодом, ожидающем на входе массив.
(все остальное в дне про STL)

Безопасно удалять 0. Ничего не произойдет.

Ссылки. Ссылки всегда валидны.
Ссылки == синоним. Инициализируется при создании.
Нельзя изменить ссылку. Ссылка - просто еще одно имя переменной.

циклы for(инициализация; условие; итерационный счетчик)

while(условие)

do
while(условие)

continue - следующая итерация
break - выход из цикла

Рекурсия.
Элиминация хвостовой рекурсии.

При наличиии хвостовой рекурсии, функция может быть преобразованна 
в итеративную введением дополнительноо цикла.

Компиляторы сами распознают хвостовую рекурсию.

В общем случае, для каждой рекурсивной функции есть итеративный эквивалент,
правда, он бывает очень сложным. Итеративная быстрая сортировка совсем неинтуитивна.

функции

int f(формальные параметры)
{
}

int a = f(фактический параметр);

могут возвращать объект по значению, ссылку на него или указатель
формальные параметры так же бывают значением, указателем или ссылкой.
Бывают указатели на функции.

Параметры по умолчанию.
Пергрузка функций.
Может быть несколько одноименных функций с разными формальными параметрами, с поправкой на параметры по-умолчанию. 


Передача по ссылке, по значению, по указателю.
Указатель на указатель. Ссылка на указатель.(Указатель на указатель плющит мозг. Придумать понятную метафору.)

const - запрещает изменение.

потоки ввода/вывода.

std::cin ввода
std::cout вывода
std::cerr ошибок


День 2.	
Структуры. Перечисленния. Объединения. Классы. Управление доступом. Указатель this. inline-функции.
Отношение дружбы. Константные(const), изменяемые(mutable) и статические члены. Виртуальные функции. Абстрактные классы.
Наследование. Множественное и виртуальное наследование. 
Полиморфизм. Приведение типов. RTTI.

День 3.	
Создание объектов. Размещение на стеке и в куче.

День 4.	 
Шаблоны. Принцип интерфейса и поиск Кёнига.
Умные указатели. RAII.

День 5.	
Контейнеры, алгоритмы и итераторы. Алгоритмическая сложность.
Класс строки. Характеристики типов (traits). Строковые алгоритмы.
ДЗ на выходные.(Варианты ДЗ приветствуются)

День 6.
Исключения. Гарантии безопасности исключений.  	

День 7.	
Цикл сообщений. Сверхминимальный OpenGL.
Кроcсплатформенный тетрис.

День 8. 
Некоторые паттерны проектирования.
Продолжаем разрабатывать тетрис. Иерархия объектов.

День 9. 
Тетрис. Последние штрихи.
Какая-нибудь мелкая тема.

День 10. Контрольная работа.

За бортом осталась многопоточность. Нужно что-то кроссплатформенное, вроде pthreads/boost.
Хотя, хотелось бы на примере API, чтобы рассказать, что-куда-откуда-зачем.