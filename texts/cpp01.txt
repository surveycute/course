***Программа курса С++.***

День 1.	
Переменные, массивы, std::vector(сразу после массивов), циклы, указатели, ссылки, функции, перегрузка функций.
Потоки ввода/вывода. Манипуляторы и флаги.

POD-type.

При копировании, как набора байт, в другое место и обратно, получим то же самое.

Переменные бывают автоматические и статические.

Статические инициализируются один раз и имеют время жизни такое же, как время жизни программы.
Автоматическая - размещается на стеке, время жизни зависит от области видимости.

char, short, long(int), long long, float, double

указатель int* a; адрес в памяти. Инкремент указателя перемещает его на sizeof(type).
Бывает указатель 0. 

указатель на непрерывную область памяти. Массив значений.
int* a;
new
new []
delete
delete [] <--- устаревшая форма.

int* a = new int[100];

Многомерные массивы.
постоянного размера double[3][3];
С пропущенным размером double[][3];

-ручное управление памятью.
-Нужно следить и вовремя очистить.
-Нужно быть уверенным, что указатель инициализирован.
-Нужно проверять выход за диапазон.
-Нужно вручну расширять и сокращать, при изменении объема данных.

Гораздо безопаснее и удобнее
std::vector - абстракция массива.
Сам растет, сам сужается.
Сам себя удалит.
Проверка диапазона.
можно использовать со старым кодом, ожидающем на входе массив.
(все остальное в дне про STL)

Безопасно удалять 0. Ничего не произойдет.

Ссылки. Ссылки всегда валидны.
Ссылки == синоним. Инициализируется при создании.
Нельзя изменить ссылку. Ссылка - просто еще одно имя переменной.

циклы for(инициализация; условие; итерационный счетчик)

while(условие)

do
while(условие)

continue - следующая итерация
break - выход из цикла

Рекурсия.
Элиминация хвостовой рекурсии.

При наличиии хвостовой рекурсии, функция может быть преобразованна 
в итеративную введением дополнительноо цикла.

Компиляторы сами распознают хвостовую рекурсию.

В общем случае, для каждой рекурсивной функции есть итеративный эквивалент,
правда, он бывает очень сложным. Итеративная быстрая сортировка совсем неинтуитивна.

функции

int f(формальные параметры)
{
}

int a = f(фактический параметр);

могут возвращать объект по значению, ссылку на него или указатель
формальные параметры так же бывают значением, указателем или ссылкой.
Бывают указатели на функции.

Параметры по умолчанию.
Пергрузка функций.
Может быть несколько одноименных функций с разными формальными параметрами, с поправкой на параметры по-умолчанию. 


Передача по ссылке, по значению, по указателю.
Указатель на указатель. Ссылка на указатель.(Указатель на указатель плющит мозг. Придумать понятную метафору.)

const - запрещает изменение.

потоки ввода/вывода.

std::cin ввода - istream
std::cout вывода  - ostream
std::cerr ошибок  - ostream
<< и >> определены для всех встроенных типов и строк (char*)

манипуляторы:

endl 	при выводе перейти на новую строку;
ends 	вывести нулевой байт (признак конца строки символов);
flush 	немедленно вывести и опустошить все промежуточные буферы;
dec 	выводить числа в десятичной системе (действует по умолчанию);
oct 	выводить числа в восьмеричной системе;
hex 	выводить числа в шестнадцатиричной системе счисления;
setw (int n) 	установить ширину поля вывода в n символов (n – целое число);
setfill(int n) 	установить символ-заполнитель; этим символом выводимое значение будет дополняться до необходимой ширины;
setprecision(int n) 	установить количество цифр после запятой при выводе вещественных чисел;
setbase(int n) 	установить систему счисления для вывода чисел; n может принимать значения 0, 2, 8, 10, 16, причем 0 означает систему счисления по умолчанию, т.е. 10.

Те же манипуляторы (за исключением endl и ends) могут использоваться и при вводе. В этом случае они описывают представление вводимых чисел. 
Кроме того, имеется манипулятор, работающий только при вводе, это ws. 
Данный манипулятор переключает вводимый поток в такой режим, 
при котором все пробелы (включая табуляцию, переводы строки, переводы каретки и переводы страницы) будут вводиться. 
По умолчанию эти символы воспринимаются как разделители между атрибутами ввода.

int x;
// ввести шестнадцатиричное число
cin  >>  hex  >>  x;

cerr << "x = " << x;
            
понимается как
(cerr.operator<<("x = ")).operator<<(x);

Строковые потоки

Специальным случаем потоков являются строковые потоки, представленные классом strstream. Отличие этих потоков состоит в том, что все операции происходят в памяти. Фактически такие потоки формируют форматированную строку символов, заканчивающуюся нулевым байтом. Строковые потоки применяются, прежде всего, для того, чтобы облегчить форматирование данных в памяти. 

Например, в приведенном в предыдущей главе классе Exception для исключительной ситуации можно добавить сообщение. Если мы хотим составить сообщение из нескольких частей, то может возникнуть необходимость форматирования этого сообщения: 
// произошла ошибка
strstream  ss;
ss  << "Ошибка ввода-вывода, регистр: " 
    <<  oct  <<  reg1;
ss  << "Системная ошибка номер: " << dec  
    <<  errno  <<  ends;
String  msg(ss.str());
ss.rdbuf()->freeze(0);
Exception ex(Exception::INTERNAL_ERROR, msg);
throw  ex;

Сначала создается объект типа strstream с именем ss. Затем в созданный строковый поток выводятся сформатированные нужным образом данные. 
Отметим, что в конце мы вывели манипулятор ends, который добавил необходимый для символьной строки байтов нулевой байт. 
Метод str() класса strstream предоставляет доступ к сформатированной строке (тип его возвращаемого значения – char*). 
Следующая строка освобождает память, занимаемую строковым потоком (подробнее об этом рассказано ниже). 
Последние две строки создают объект типа Exception с типом ошибки INTERNAL_ERROR и сформированным сообщением и вызывают исключительную ситуацию. 

Важное свойство класса strstream состоит в том, что он автоматически выделяет нужное количество памяти для хранения строк. 
В следующем примере функция split_numbers выделяет числа из строки, состоящей из нескольких чисел, разделенных пробелом, и печатает их по одному на строке. 
#include  <strstream.h> //Visual Studio header
void
split_numbers(const  char* s)
{
    strstream  iostr;
    iostr  <<  s  <<  ends;
    int  x;
    while  (iostr  >>  x) 
    cout  <<  x<<  endl;
}
int
main()
{
    split_numbers("123  34  56  932");
    return 1;
}

Как видно из этого примера, независимо от того, какова на самом деле длина входной строки, объект iostr автоматически выделяет память, 
и при выходе из функции split_numbers, когда объект уничтожается, память будет освобождена. 

Однако из данного правила есть одно исключение. 
Если программа обращается непосредственно к хранимой в объекте строке с помощью метода str (), 
то объект перестает контролировать эту память, а это означает, что при уничтожении объекта память не будет освобождена. 
Для того чтобы память все-таки была освобождена, необходимо вызвать метод rdbuf()->freeze(0) (см. предыдущий пример).

fstream
В библиотеке Си++ для ввода-вывода файлов существуют классы ofstream (вывод) и ifstream (ввод). 
Оба они выведены из класса fstream. 

ofstream(const char* szName, 
         int nMode = ios::out,
         int  nProt  =  filebuf::openprot);

Первый аргумент – имя выходного файла. Второй аргумент задает режим, в котором открывается поток. Этот аргумент – битовое ИЛИ следующих величин: 
ios::app 	при записи данные добавляются в конец файла, даже если текущая позиция была перед этим перемещена;
ios::ate 	при создании потока текущая позиция помещается в конец файла; однако, в отличие от режима app, запись ведется в текущую позицию;
ios::in 	поток создается для ввода; если файл уже существует, он сохраняется;
ios::out 	поток создается для вывода (по умолчанию);
ios::trunc 	если файл уже существует, стереть содержимое и установить длину 0; по умолчанию, если не заданы ios::ate, ios::app или ios::in;
ios::binary считать данные бинарными.


Третий аргумент используется только в том случае, если создается новый файл; он определяет параметры создаваемого файла. 

ofstream::open 
void  open(const  char*  szName,  
           int  nMode  =  ios::out,
           int nProt  =  filebuf::openprot);

Только после того, как поток создан и соединен с определенным файлом (либо с помощью конструктора с аргументами, либо с помощью метода open), можно выполнять вывод. 
Выводятся данные операцией <<. Кроме того, данные можно вывести с помощью методов write или put: 
ostream& write(const char* pch,  
               int nCount);
ostream& put(char ch);

Метод write выводит указанное количество байтов (nCount), расположенных в памяти, начиная с адреса pch. Метод put выводит один байт. 

Для того чтобы переместить текущую позицию, используется метод seekp: 
ostream&  seekp(streamoff  off,  
                ios::seek_dir  dir);

Первый аргумент – целое число, смещение позиции в байтах. Второй аргумент определяет, откуда отсчитывается смещение:
ios::beg 	смещение от начала файла
ios::cur 	смещение от текущей позиции
ios::end 	смещение от конца файла

Сместив текущую позицию, операции вывода продолжаются с нового места файла. 

После завершения вывода можно выполнить метод close, который выводит внутренние буферы в файл и отсоединяет поток от файла. 
То же самое происходит и при уничтожении объекта. 

Класс ifstream, осуществляющий ввод из файлов, работает аналогично. 
При создании объекта типа ifstream в качестве аргумента конструктора можно задать имя существующего файла: 
ifstream(const  char*  szName,  int  nMode  =  ios::in,
         int  nProt  =  filebuf::openprot);

Можно воспользоваться стандартным конструктором, а подсоединиться к файлу с помощью метода open. 

Чтение из файла производится операцией >> или методами read или get: 
istream&  read(char*  pch,  int  nCount);
istream&  get(char&  rch);

Метод read вводит указанное количество байтов (nCount) в память, начиная с адреса pch. Метод get вводит один байт. 

Так же, как и для вывода, текущую позицию ввода можно изменить с помощью метода seekp, 
а по завершении выполнения операций закрыть файл с помощью close или просто уничтожить объект.

С каждым потоком (istream или ostream) связано определенное состояние. Нестандартные ситуации и ошибки обрабатываются с помощью проверки и установки состояния подходящим образом.

Узнать состояние потока можно с помощью операций над классом ios:
class ios { //ios является базовым для ostream и istream
    //...
public:
    int eof() const;     // дошли до конца файла
    int fail() const;    // следующая операция будет неудачна
    int bad() const;     // поток испорчен
    int good() const;    // следующая операция будет успешной
    //...
};
               

Последняя операция ввода считается успешной, если состояние задается good() или eof(). Если состояние задается good(), то последующая операция ввода может быть успешной, в противном случае она будет неудачной. Применение операции ввода к потоку в состоянии, задаваемом не good(), считается пустой операцией. Если произошла неудача при попытке чтения в переменную v, то значение v не изменилось (оно не изменится, если v имеет тип, управляемый функциями члена из istream или ostream). Различие между состояниями, задаваемыми как fail() или как bad() уловить трудно, и оно имеет смысл только для разработчиков операций ввода. Если состояние есть fail(), то считается, что поток не поврежден, и никакие символы не пропали; о состоянии bad() ничего сказать нельзя.

Значения, обозначающие эти состояния, определены в классе ios:
class ios {
    //...
public:
    enum io_state {
        goodbit=0,
        eofbit=1,
        filebit=2,
        badbit=4,
    };
    //...
};
            

Истинные значения состояний зависят от реализации, и указанные значения приведены только, чтобы избежать синтаксически неправильных конструкций.

Проверять состояние потока можно следующим образом:
switch (cin.rdstate()) {
case ios::goodbit:
    // последняя операция с cin была успешной
    break;
case ios::eofbit:
    // в конце файла
    break;
 case ios::filebit:
    // некоторый анализ ошибки
    // возможно неплохой
    break;
  case ios::badbit:
    //  cin возможно испорчен
    break;
  }
  
Заполнение поля заданными символами или выравнивание можно установить с помощью функции fill(), например:
cout.width(4);
cout.fill('#');
cout << '(' << "ab" << ')';
     
напечатает
###(ab)

cout << '';

####

width задает минимальную ширину поля. По умолчанию заполняет пробелами.

